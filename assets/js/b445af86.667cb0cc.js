"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[77227],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),u=a,h=c["".concat(s,".").concat(u)]||c[u]||m[u]||o;return n?i.createElement(h,r(r({ref:t},p),{},{components:n})):i.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89259:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=n(7896),a=(n(2784),n(30876));const o={title:"\ud83d\udcd3 4.2.3.4 Adding Wait Time to the Queue Part 2",id:"4234-adding-wait-time-to-the-queue-part-2",slug:"4234-adding-wait-time-to-the-queue-part-2",hide_table_of_contents:!0,sidebar_position:26,day:"wednesday",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/3e_adding_wait_time_to_the_queue_part_2.md"},r=void 0,l={unversionedId:"fidgetech-4-react/react-with-redux/4234-adding-wait-time-to-the-queue-part-2",id:"fidgetech-4-react/react-with-redux/4234-adding-wait-time-to-the-queue-part-2",title:"\ud83d\udcd3 4.2.3.4 Adding Wait Time to the Queue Part 2",description:'In the last lesson, we covered the "business" logic for updating a ticket\'s elapsed time in the Redux store. In the process, we had to write and test a reducer action, update and test another reducer action, and write action creators.',source:"@site/docs/fidgetech-4-react/react-with-redux/3e-adding-wait-time-to-the-queue-part-2.md",sourceDirName:"fidgetech-4-react/react-with-redux",slug:"/fidgetech-4-react/react-with-redux/4234-adding-wait-time-to-the-queue-part-2",permalink:"/fidgetech-4-react/react-with-redux/4234-adding-wait-time-to-the-queue-part-2",draft:!1,tags:[],version:"current",sidebarPosition:26,frontMatter:{title:"\ud83d\udcd3 4.2.3.4 Adding Wait Time to the Queue Part 2",id:"4234-adding-wait-time-to-the-queue-part-2",slug:"4234-adding-wait-time-to-the-queue-part-2",hide_table_of_contents:!0,sidebar_position:26,day:"wednesday",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/3e_adding_wait_time_to_the_queue_part_2.md"},sidebar:"fidgetech-4-react",previous:{title:"\ud83d\udcd3 4.2.3.3 Adding Wait Time to the Queue",permalink:"/fidgetech-4-react/react-with-redux/4233-adding-wait-time-to-the-queue"},next:{title:"\ud83d\udcd3 4.2.4.1 Technical Interview Practice: React and Redux",permalink:"/fidgetech-4-react/react-with-redux/4241-technical-interview-practice-react-and-redux"}},s={},d=[{value:"Changes to <code>NewTicketForm.js</code>",id:"changes-to-newticketformjs",level:3},{value:"Changes to <code>TicketControl.js</code>",id:"changes-to-ticketcontroljs",level:3},{value:"Changes to <code>TicketList.js</code>",id:"changes-to-ticketlistjs",level:3},{value:"Changes to <code>Ticket.js</code>",id:"changes-to-ticketjs",level:3},{value:"Changes to <code>EditTicketForm.js</code>",id:"changes-to-editticketformjs",level:3},{value:"Conclusion",id:"conclusion",level:3}],p={toc:d},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'In the last lesson, we covered the "business" logic for updating a ticket\'s elapsed time in the Redux store. In the process, we had to write and test a reducer action, update and test another reducer action, and write action creators.'),(0,a.kt)("p",null,"Now that we're ready to implement this functionality in the UI, we should think carefully about where it's needed."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We know that a new ticket should have a ",(0,a.kt)("inlineCode",{parentName:"li"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"formattedWaitTime")," property, which means that we'll need to add these in ",(0,a.kt)("inlineCode",{parentName:"li"},"NewTicketForm.js"),"."),(0,a.kt)("li",{parentName:"ul"},"Next, we'll need to implement a timer in our ",(0,a.kt)("inlineCode",{parentName:"li"},"TicketControl")," component. Fortunately, we added most of the code for that a few lessons ago. We'll go over it again in this lesson."),(0,a.kt)("li",{parentName:"ul"},"When we demonstrated how our timer would work, we created an ",(0,a.kt)("inlineCode",{parentName:"li"},"updateTicketElapsedWaitTime()")," method that logged ",(0,a.kt)("inlineCode",{parentName:"li"},'"tick"')," to the queue. In this lesson, we'll update that method to actually update the elapsed wait time for a ticket."),(0,a.kt)("li",{parentName:"ul"},"Once that's complete, we'll need to pass the ",(0,a.kt)("inlineCode",{parentName:"li"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"formattedWaitTime")," properties of a ticket to the ",(0,a.kt)("inlineCode",{parentName:"li"},"Ticket")," component via ",(0,a.kt)("inlineCode",{parentName:"li"},"TicketList"),". (And we can't forget to add PropTypes, either.)"),(0,a.kt)("li",{parentName:"ul"},"We'll also need to make a tweak to our ",(0,a.kt)("inlineCode",{parentName:"li"},"EditTicketForm")," so that ",(0,a.kt)("inlineCode",{parentName:"li"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"formattedWaitTime")," don't become undefined when we update tickets. ")),(0,a.kt)("p",null,"To recap, we'll need to make changes to the following five components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"NewTicketForm.js")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TicketControl.js")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TicketList.js")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Ticket.js")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"EditTicketForm.js"))),(0,a.kt)("p",null,"We'll make the changes in that order."),(0,a.kt)("h3",{id:"changes-to-newticketformjs"},"Changes to ",(0,a.kt)("inlineCode",{parentName:"h3"},"NewTicketForm.js")),(0,a.kt)("p",null,"We just need to make a few small changes to ",(0,a.kt)("inlineCode",{parentName:"p"},"NewTicketForm.js"),":"),(0,a.kt)("div",{class:"filename"},"src/components/NewTicketForm.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\nimport Moment from 'moment';\n...\n\nfunction NewTicketForm(props){\n  function handleNewTicketFormSubmission(event) {\n    event.preventDefault();\n    props.onNewTicketCreation({\n      names: event.target.names.value,\n      location: event.target.location.value, \n      issue: event.target.issue.value,\n      id: v4(),\n      timeOpen: new Moment(),\n      formattedWaitTime: new Moment().fromNow(true)\n    });\n  }\n...\n")),(0,a.kt)("p",null,"First we need to import Moment.js. Then we need to add ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," properties to the ticket object. ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," will be set to the value of a ",(0,a.kt)("inlineCode",{parentName:"p"},"new Moment()"),". That way, when a user adds a ticket via the form and this function is triggered, a Moment-formatted timestamp will be created for a ticket's ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," property. Meanwhile, ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," will be set to the formatted elapsed time since the ticket was opened. (We discussed the ",(0,a.kt)("inlineCode",{parentName:"p"},"fromNow(true)")," method in our lesson on Moment.js.)"),(0,a.kt)("p",null,"If we wanted to, we could define ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketControl.js")," instead. After all, these aren't values that are being pulled from the form. ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketControl.js")," actually processes the new tickets and passes them to the Redux store, so why not add these values to ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketControl"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"handleAddingNewTicketToList()")," method instead?"),(0,a.kt)("p",null,"An argument could be made for that - but there are advantages to creating all the properties a ticket needs in the same place. This keeps our code modular and makes it easier for other developers to read. Since ",(0,a.kt)("inlineCode",{parentName:"p"},"NewTicketForm")," already creates the other properties, it makes sense to create the ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," properties here as well."),(0,a.kt)("h3",{id:"changes-to-ticketcontroljs"},"Changes to ",(0,a.kt)("inlineCode",{parentName:"h3"},"TicketControl.js")),(0,a.kt)("p",null,"Most of our updates will be made in this component. However, we already implemented almost all of the changes we need when we learned about lifecycle methods and implemented a timer. Here's what we have so far from that lesson:"),(0,a.kt)("div",{class:"filename"},"src/components/TicketControl.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\n\n  componentDidMount() {\n    this.waitTimeUpdateTimer = setInterval(() =>\n      this.updateTicketElapsedWaitTime(),\n      60000\n    );\n  }\n\n  componentWillUnmount(){\n    clearInterval(this.waitTimeUpdateTimer);\n  }\n\n  updateTicketElapsedWaitTime = () => {\n    // New code will go here.\n  }\n")),(0,a.kt)("p",null,"A few things to note:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We've changed the interval of our ",(0,a.kt)("inlineCode",{parentName:"p"},"setInterval()")," function to ",(0,a.kt)("inlineCode",{parentName:"p"},"60000")," because the help queue at Epicodus updates every minute.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"There's no need to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDidUpdate()")," lifecycle method here so it's been removed.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The only other new code we will need to add to ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketControl")," will go in ",(0,a.kt)("inlineCode",{parentName:"p"},"updatedTicketElapsedWaitTime()"),". Every 60 seconds, this function will be called. As you may have already guessed, we'll be dispatching our new action here."))),(0,a.kt)("p",null,"Let's add the code now:"),(0,a.kt)("div",{class:"filename"},"src/components/TicketControl.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\nupdateTicketElapsedWaitTime = () => {\n  const { dispatch } = this.props;\n  Object.values(this.props.mainTicketList).forEach(ticket => {\n    const newFormattedWaitTime = ticket.timeOpen.fromNow(true);\n    const action = a.updateTime(ticket.id, newFormattedWaitTime);\n    dispatch(action);\n  });\n}\n...\n")),(0,a.kt)("p",null,"Let's cover exactly what this function is doing. This will all be review of concepts we've already covered."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We start by deconstructing the ",(0,a.kt)("inlineCode",{parentName:"p"},"dispatch")," function from ",(0,a.kt)("inlineCode",{parentName:"p"},"this.props"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We iterate over the values in the ",(0,a.kt)("inlineCode",{parentName:"p"},"mainTicketList"),". For each ticket, we determine the ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," using the ",(0,a.kt)("inlineCode",{parentName:"p"},"fromNow()")," method from Moment.js. You may wonder how we're able to use this method without importing Moment.js - we instantiated the Moment object in another component and the ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," property already has access to the ",(0,a.kt)("inlineCode",{parentName:"p"},"fromNow()")," method. Finally, we create and dispatch an action to update the time for a ticket.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Note that we use ",(0,a.kt)("inlineCode",{parentName:"p"},"forEach()"),". Technically, we could use ",(0,a.kt)("inlineCode",{parentName:"p"},"map()")," and it would work. However, this function only has side effects (updating the store) and ",(0,a.kt)("inlineCode",{parentName:"p"},"map()")," is supposed to return something without side effects. For that reason, ",(0,a.kt)("inlineCode",{parentName:"p"},"forEach()")," communicates our intentions here."))),(0,a.kt)("p",null,"There's another important thing to note about this code. It's not going to scale up very well. Every minute, this function will dispatch an action for ",(0,a.kt)("em",{parentName:"p"},"every single ticket")," in the queue. That wouldn't be very efficient if our queue was meant to handle thousands of tickets. Since this is just a simple implementation - and our queue doesn't need to handle a lot of tickets anyway - we won't worry about it. However, you may want to see if you can refactor it to be more efficient on your own."),(0,a.kt)("h3",{id:"changes-to-ticketlistjs"},"Changes to ",(0,a.kt)("inlineCode",{parentName:"h3"},"TicketList.js")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js")," component needs to have access to the ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," property. In order to pass these props to ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js"),", though, we first need to pass them to ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketList.js"),", which is the direct parent of ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js")," and the child of ",(0,a.kt)("inlineCode",{parentName:"p"},"TicketControl.js"),":"),(0,a.kt)("div",{class:"filename"},"src/components/TicketList.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\nfunction TicketList(props){\n  return (\n    <React.Fragment>\n      <hr/>\n      {Object.values(props.ticketList).map((ticket) => {\n        return <Ticket\n          whenTicketClicked = { props.onTicketSelection }\n          names={ticket.names}\n          location={ticket.location}\n          issue={ticket.issue}\n          formattedWaitTime={ticket.formattedWaitTime}\n          id={ticket.id}\n          key={ticket.id}/>\n      })}\n    </React.Fragment>\n  );\n}\n...\n")),(0,a.kt)("p",null,"We just add ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," as a prop to pass down to ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js"),". We don't need to pass ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," as a prop because we won't be displaying it in ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js"),". We'll only be showing the ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime"),"."),(0,a.kt)("h3",{id:"changes-to-ticketjs"},"Changes to ",(0,a.kt)("inlineCode",{parentName:"h3"},"Ticket.js")),(0,a.kt)("p",null,"Now we just need to add ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," as a prop type to ",(0,a.kt)("inlineCode",{parentName:"p"},"Ticket.js")," and then actually use the prop in our React fragment:"),(0,a.kt)("div",{class:"filename"},"src/components/Ticket.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\n\nfunction Ticket(props){\n  return (\n    <React.Fragment>\n      <div onClick = {()=> props.whenTicketClicked(props.id)}>\n        <h3>{props.location} - {props.names}</h3>\n        <p><em>{props.issue}</em></p>\n        { /* new code below. */}\n        <p><em>{props.formattedWaitTime}</em></p>\n        <hr/>\n      </div>\n    </React.Fragment>\n  );\n}\n\nTicket.propTypes = {\n  // New prop type added.\n  ...\n  formattedWaitTime: PropTypes.string\n};\n\n...\n")),(0,a.kt)("p",null,"Only two lines of code have been added here. Comments have been included to highlight the new lines of code."),(0,a.kt)("h3",{id:"changes-to-editticketformjs"},"Changes to ",(0,a.kt)("inlineCode",{parentName:"h3"},"EditTicketForm.js")),(0,a.kt)("p",null,"If we run our application, everything will work correctly when we add a new ticket. The time for a new ticket will display as ",(0,a.kt)("inlineCode",{parentName:"p"},"'A few seconds'"),". If we wait a minute, it will update to ",(0,a.kt)("inlineCode",{parentName:"p"},"'One minute'"),"."),(0,a.kt)("p",null,"However, if we edit a ticket, the elapsed time will no longer display. See if you can figure out the issue on your own first - it's a quick fix."),(0,a.kt)("p",null,"The issue is in the ",(0,a.kt)("inlineCode",{parentName:"p"},"handleEditTicketFormSubmission()")," function. When we call ",(0,a.kt)("inlineCode",{parentName:"p"},"props.onEditTicket()"),", we don't specify that the ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," properties should be included in the ticket object. Remember that when we update a ticket, it's almost exactly the same as adding a new ticket - we just happen to be overwriting the pre-existing ticket with the same ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),". To fix this issue, we just need to pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"timeOpen")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," properties into the method."),(0,a.kt)("div",{class:"filename"},"src/components/EditTicketForm.js"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"...\nfunction handleEditTicketFormSubmission(event) {\n  event.preventDefault();\n  props.onEditTicket({\n    names: event.target.names.value, \n    location: event.target.location.value, \n    issue: event.target.issue.value, \n    id: ticket.id, \n    timeOpen: ticket.timeOpen, \n    formattedWaitTime: ticket.formattedWaitTime \n  });\n}\n...\n")),(0,a.kt)("p",null,"At this point, our help queue should now show the elapsed time since the ticket was opened regardless of whether the ticket was updated."),(0,a.kt)("h3",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"As we've already stated, you won't be expected to add this kind of functionality to your independent project. The most important takeaway from these lessons isn't using a timer or incorporating Moment.js - although it's fun to do both - or getting the help queue fully functional. Instead, it's essential to know about how the component lifecycle works - and to have at least a basic understanding of the following methods and what they do:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"constructor()"),": Called when a state-based component is instantiated;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"render()"),": Called both when a component is being loaded and also when it's updated;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"componentDidMount()"),": Called when a component has finished updating the DOM;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"componentDidUpdate()"),": Called immediately after a component updates;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"componentWillUnmount()"),"; Called right before a component is unmounted and destroyed.")))}m.isMDXComponent=!0}}]);