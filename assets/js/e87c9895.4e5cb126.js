"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[18640],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=i,m=u["".concat(o,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:i,s[1]=l;for(var d=2;d<r;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},41060:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7896),i=(n(2784),n(30876));const r={title:"\ud83d\udcd3 4.4.0.4 Building an API Application with React and Redux",id:"4404-building-an-api-application-with-react-and-redux",slug:"4404-building-an-api-application-with-react-and-redux",hide_table_of_contents:!0,sidebar_position:4,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/0d_testing_and_writing_our_reducers.md"},s=void 0,l={unversionedId:"fidgetech-4-react/react-with-apis/4404-building-an-api-application-with-react-and-redux",id:"fidgetech-4-react/react-with-apis/4404-building-an-api-application-with-react-and-redux",title:"\ud83d\udcd3 4.4.0.4 Building an API Application with React and Redux",description:"We're now ready to start building an application that makes an API call and uses Redux to handle state. We'll begin by writing and testing a new reducer just as we did in a previous section, when we were first learning Redux. In the process, we'll also create constants for our actions as well as action creators, which we'll test as well. This content is mostly review but it's worth reinforcing good habits like testing and getting more practice with setting up our own reducers.",source:"@site/docs/fidgetech-4-react/react-with-apis/0d-testing-and-writing-our-reducers.md",sourceDirName:"fidgetech-4-react/react-with-apis",slug:"/fidgetech-4-react/react-with-apis/4404-building-an-api-application-with-react-and-redux",permalink:"/fidgetech-4-react/react-with-apis/4404-building-an-api-application-with-react-and-redux",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"\ud83d\udcd3 4.4.0.4 Building an API Application with React and Redux",id:"4404-building-an-api-application-with-react-and-redux",slug:"4404-building-an-api-application-with-react-and-redux",hide_table_of_contents:!0,sidebar_position:4,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/0d_testing_and_writing_our_reducers.md"},sidebar:"fidgetech-4-react",previous:{title:"\ud83d\udcd3 4.4.0.3 Introduction to Redux Middleware",permalink:"/fidgetech-4-react/react-with-apis/4403-introduction-to-redux-middleware"},next:{title:"\ud83d\udcd3 4.4.0.5 Writing Custom Middleware",permalink:"/fidgetech-4-react/react-with-apis/4405-writing-custom-middleware"}},o={},d=[{value:"Setting Up Our Project",id:"setting-up-our-project",level:2},{value:"Planning Our State",id:"planning-our-state",level:2},{value:"Add Constants for Reducer Actions",id:"add-constants-for-reducer-actions",level:3},{value:"Testing and Writing Our Reducer&#39;s Default State",id:"testing-and-writing-our-reducers-default-state",level:2},{value:"Testing and Writing <code>REQUEST_HEADLINES</code>",id:"testing-and-writing-request_headlines",level:2},{value:"Testing and Writing <code>GET_HEADLINES_SUCCESS</code>",id:"testing-and-writing-get_headlines_success",level:2},{value:"Testing and Writing <code>GET_HEADLINES_FAILURE</code>",id:"testing-and-writing-get_headlines_failure",level:2},{value:"Testing and Writing Action Creators",id:"testing-and-writing-action-creators",level:2},{value:"Summary",id:"summary",level:2}],c={toc:d},u="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We're now ready to start building an application that makes an API call and uses Redux to handle state. We'll begin by writing and testing a new reducer just as we did in a previous section, when we were first learning Redux. In the process, we'll also create constants for our actions as well as action creators, which we'll test as well. This content is mostly review but it's worth reinforcing good habits like testing and getting more practice with setting up our own reducers."),(0,i.kt)("h2",{id:"setting-up-our-project"},"Setting Up Our Project"),(0,i.kt)("p",null,"We will modify our existing API project to use Redux."),(0,i.kt)("p",null,"Add the following directories to ",(0,i.kt)("inlineCode",{parentName:"p"},"src"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"__tests__")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reducers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actions"))),(0,i.kt)("p",null,"Next, add the following directories to ",(0,i.kt)("inlineCode",{parentName:"p"},"src/__tests__"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reducers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actions"))),(0,i.kt)("p",null,"Now we're ready to start planning our application state - and how our reducers will update it."),(0,i.kt)("h2",{id:"planning-our-state"},"Planning Our State"),(0,i.kt)("p",null,"There is a key difference between the React/Redux applications we built two sections ago and the one we're building now - this one will incorporate middleware to handle asynchronous code. We'll handle the asynchronous code in a future lesson. For now, we'll focus on all the reducer actions we can create. Because our reducers need to be pure and can't use async code, we can keep our actions very simple."),(0,i.kt)("p",null,"Instead, let's think about the default state of our store and the actions our reducer will need to take for that state to be updated."),(0,i.kt)("p",null,"We already know what the default state will be - it's the same state that we used when we made an API call with just React and ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch()"),". The difference is that our state will belong to a Redux store, not a component's local state."),(0,i.kt)("p",null,"Our default state will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  isLoading: false,\n  headlines: [],\n  error: null\n}\n")),(0,i.kt)("p",null,"This makes sense - before we make an API call, ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," will be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". Then, when we make the API call, ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," will be set to true. Finally, when the response is returned, ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," will be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," again - and a reducer action will also pass either the current ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," or an ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," to the Redux store."),(0,i.kt)("p",null,"It should be clear that we need to make a distinction between ",(0,i.kt)("em",{parentName:"p"},"requesting")," data from an API and ",(0,i.kt)("em",{parentName:"p"},"receiving")," data from the API. We can't just have a single action handling both of these things - even though we were able to handle both with a single ",(0,i.kt)("inlineCode",{parentName:"p"},"makeApiCall()")," method when we just used ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch()")," with React."),(0,i.kt)("p",null,"The act of ",(0,i.kt)("em",{parentName:"p"},"requesting")," data, from the perspective of Redux, just means setting ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," to true. We'll use an async action to make the actual API call during this time. However, our reducer can't worry about that because it needs to be pure. Then, when our async action is complete, it will trigger another action that deals with ",(0,i.kt)("em",{parentName:"p"},"receiving")," data. More on that soon."),(0,i.kt)("p",null,"It should now be clear that our reducer will need three actions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'REQUEST_HEADLINES'"),": This action will be dispatched when we ",(0,i.kt)("em",{parentName:"li"},"request")," data. It will set ",(0,i.kt)("inlineCode",{parentName:"li"},"isLoading")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'GET_HEADLINES_SUCCESS'"),": This action will be dispatched when we receive a response for a successful API call. It will set ",(0,i.kt)("inlineCode",{parentName:"li"},"isLoading")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," and will include a ",(0,i.kt)("inlineCode",{parentName:"li"},"headlines")," property with the API response's payload."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'GET_HEADLINES_FAILURE'"),": This action will be dispatched when we receive a response from a failed API call. It will set ",(0,i.kt)("inlineCode",{parentName:"li"},"isLoading")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," and will include an ",(0,i.kt)("inlineCode",{parentName:"li"},"error")," property the API response's error message.")),(0,i.kt)("h3",{id:"add-constants-for-reducer-actions"},"Add Constants for Reducer Actions"),(0,i.kt)("p",null,"Before we go any further, let's create constants for our actions (just as we did in the React with Redux course section):"),(0,i.kt)("div",{class:"filename"},"src/actions/ActionTypes.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export const REQUEST_HEADLINES='REQUEST_HEADLINES'\nexport const GET_HEADLINES_FAILURE='GET_HEADLINES_FAILURE'\nexport const GET_HEADLINES_SUCCESS='GET_HEADLINES_SUCCESS'\n")),(0,i.kt)("h2",{id:"testing-and-writing-our-reducers-default-state"},"Testing and Writing Our Reducer's Default State"),(0,i.kt)("p",null,"Now we have everything we need for our first test. Remember, our reducer should just return the unchanged state if no action is specified."),(0,i.kt)("p",null,"Here's our test:"),(0,i.kt)("div",{class:"filename"},"src/__tests__/reducers/headlines-reducer.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import headlinesReducer from '../../reducers/headlines-reducer';\n\ndescribe('headlinesReducer', () => {\n\n  const defaultState = {\n    isLoading: false,\n    headlines: [],\n    error: null\n  };\n\n  test('should successfully return the default state if no action is passed into it', () => {\n    expect(headlinesReducer(defaultState, {type: null })).toEqual({\n        isLoading: false,\n        headlines: [],\n        error: null\n      });\n  });\n});\n")),(0,i.kt)("p",null,"We start by importing our reducer (which we haven't created yet - we'll do that in a moment). Then we store the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultState")," in a constant in our ",(0,i.kt)("inlineCode",{parentName:"p"},"describe")," block. Finally, our test verifies that if no action type is specified, the same state is returned."),(0,i.kt)("p",null,"Next, we need to create our reducer:"),(0,i.kt)("div",{class:"filename"},"src/reducers/headlines-reducer.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const defaultState = {\n  isLoading: false,\n  headlines: [],\n  error: null\n}\n\nexport default (state = defaultState, action) => {\n  return state;\n};\n")),(0,i.kt)("p",null,"We store the default state in a constant. For now, our reducer only returns the state that's passed in (which defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultState"),"). Our test will pass."),(0,i.kt)("h2",{id:"testing-and-writing-request_headlines"},"Testing and Writing ",(0,i.kt)("inlineCode",{parentName:"h2"},"REQUEST_HEADLINES")),(0,i.kt)("p",null,"Now we're ready to write a test for our ",(0,i.kt)("inlineCode",{parentName:"p"},"REQUEST_HEADLINES")," action:"),(0,i.kt)("div",{class:"filename"},"src/__tests__/reducers/headlines-reducer.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\nimport * as c from './../../actions/ActionTypes';\n\ndescribe('headlinesReducer', () => {\n\n  let action; // Don't forget to declare action as a variable.\n  ...\n\n  ...\n\n  test('requesting headlines should successfully change isLoading from false to true', () => {\n    action = {\n      type: c.REQUEST_HEADLINES\n    };\n\n    expect(headlinesReducer(defaultState, action)).toEqual({\n      isLoading: true,\n      headlines: [],\n      error: null\n    });\n  });\n});\n")),(0,i.kt)("p",null,"First, we need to make sure we import our constants from ",(0,i.kt)("inlineCode",{parentName:"p"},"ActionTypes.js"),"."),(0,i.kt)("p",null,"The test itself is simple. When we call our new ",(0,i.kt)("inlineCode",{parentName:"p"},"REQUEST_HEADLINES")," action, ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," will be updated to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". Nothing else about the state will change."),(0,i.kt)("p",null,"The test will fail - let's make it pass."),(0,i.kt)("div",{class:"filename"},"src/reducers/headlines-reducer.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import * as c from './../actions/ActionTypes';\n\nlet initialState = {\n  isLoading: false,\n  headlines: [],\n  error: null\n}\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case c.REQUEST_HEADLINES:\n      return Object.assign({}, state, {\n        isLoading: true\n      });\n    default:\n      return state;\n  }\n};\n")),(0,i.kt)("p",null,"All our new action has to do is use ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.assign()")," to create a new copy of ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". Our test will now pass."),(0,i.kt)("h2",{id:"testing-and-writing-get_headlines_success"},"Testing and Writing ",(0,i.kt)("inlineCode",{parentName:"h2"},"GET_HEADLINES_SUCCESS")),(0,i.kt)("p",null,"Next, we'll write a test for our ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_HEADLINES_SUCCESS")," action. This action will be triggered if our API call is successful. Here's the test:"),(0,i.kt)("div",{class:"filename"},"src/__tests__/reducers/headlines-reducer.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\ndescribe('headlinesReducer', () => {\n\n  // previous variables\n\n  const loadingState = {\n    isLoading: true,\n    headlines: [],\n    error: null\n  };\n\n  // previous tests\n\n  test('successfully getting headlines should change isLoading to false and update headlines', () => {\n    const headlines = \"A headline\";\n    action = {\n      type: c.GET_HEADLINES_SUCCESS,\n      headlines\n    };\n\n    expect(headlinesReducer(loadingState, action)).toEqual({\n      isLoading: false,\n      headlines: \"A headline\",\n      error: null\n    });\n  });\n});\n")),(0,i.kt)("p",null,"Note that we've created a few new constants for this test. ",(0,i.kt)("inlineCode",{parentName:"p"},"loadingState")," is an object where ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". We also have a constant called ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," which is storing a string. Our reducer doesn't care what the payload will look like - for the purposes of our test, we just want to make sure our new action will update the ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," property correctly."),(0,i.kt)("p",null,"Our test will verify that when the ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_HEADLINES_SUCCESS")," action is triggered, ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," will be set to false and the ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," property will be updated to the payload (in this case, a string)."),(0,i.kt)("p",null,"Once we make sure the test fails, we can update our reducer to make it pass:"),(0,i.kt)("div",{class:"filename"},"src/reducers/headlines-reducer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import * as c from './../actions/ActionTypes';\n\nlet initialState = {\n  isLoading: false,\n  headlines: [],\n  error: null\n}\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case c.REQUEST_HEADLINES:\n      return Object.assign({}, state, {\n        isLoading: true\n      });\n    case c.GET_HEADLINES_SUCCESS:\n      return Object.assign({}, state, {\n        isLoading: false,\n        headlines: action.headlines\n      });\n    default:\n      return state;\n  }\n};\n")),(0,i.kt)("p",null,"Our new action uses ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.assign()")," to make a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," object where ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," property is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"action.headlines")," - the payload we've passed into our action."),(0,i.kt)("p",null,"If we run our tests, our latest test will pass."),(0,i.kt)("h2",{id:"testing-and-writing-get_headlines_failure"},"Testing and Writing ",(0,i.kt)("inlineCode",{parentName:"h2"},"GET_HEADLINES_FAILURE")),(0,i.kt)("p",null,"We have one final action to test and write - ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_HEADLINES_FAILURE"),". Both the test and the reducer action will look very similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_HEADLINES_SUCCESS"),". Here's the test:"),(0,i.kt)("div",{class:"filename"},"src/__tests__/reducers/headlines-reducer.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'...\n  test(\'failing to get headlines should change isLoading to false and add an error message\', () => {\n    const error = "An error";\n    action = {\n      type: c.GET_HEADLINES_FAILURE,\n      error\n    };\n\n    expect(headlinesReducer(loadingState, action)).toEqual({\n      isLoading: false,\n      headlines: [],\n      error: "An error"\n    });\n  });\n...\n')),(0,i.kt)("p",null,"We create an ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," constant that holds a string. The action itself looks very similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_HEADLINES_SUCCESS")," - the only difference is the payload. We'll expect the new state to have ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},'"An error"'),". Meanwhile, ",(0,i.kt)("inlineCode",{parentName:"p"},"headlines")," will remain an empty array since it won't change if we don't get a successful payload."),(0,i.kt)("p",null,"Verify that the test fails. Then we can update our reducer:"),(0,i.kt)("div",{class:"filename"},"src/reducers/headlines-reducer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"\nimport * as c from './../actions/ActionTypes';\n\nlet initialState = {\n  isLoading: false,\n  headlines: [],\n  error: null\n}\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case c.REQUEST_HEADLINES:\n      return Object.assign({}, state, {\n        isLoading: true\n      });\n    case c.GET_HEADLINES_SUCCESS:\n      return Object.assign({}, state, {\n        isLoading: false,\n        headlines: action.headlines\n      });\n    case c.GET_HEADLINES_FAILURE:\n      return Object.assign({}, state, {\n        isLoading: false,\n        error: action.error\n      });\n    default:\n      return state;\n  }\n};\n")),(0,i.kt)("p",null,"As we can see, the actions for success and failure are very similar - they just have different payloads."),(0,i.kt)("p",null,"At this point, our reducer is complete. It's a simple reducer with only three actions so there's no need to split it into smaller reducers and then use a root reducer. However, you should still split and combine reducers as your applications get larger."),(0,i.kt)("h2",{id:"testing-and-writing-action-creators"},"Testing and Writing Action Creators"),(0,i.kt)("p",null,"Next, we'll write action creators for our reducer actions. We'll also test these action creators. Since this is just review, we will run through this quickly. Here are the tests:"),(0,i.kt)("div",{class:"filename"},"src/__tests__/actions/index.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import * as actions from './../../actions';\nimport * as c from './../../actions/ActionTypes';\n\ndescribe('headline reducer actions', () => {\n  it('requestHeadlines should create REQUEST_HEADLINES action', () => {\n    expect(actions.requestHeadlines()).toEqual({\n      type: c.REQUEST_HEADLINES\n    });\n  });\n\n  it('getHeadlinesSuccess should create GET_HEADLINES_SUCCESS action', () => {\n    const headlines = \"A headline\";\n    expect(actions.getHeadlinesSuccess(headlines)).toEqual({\n      type: c.GET_HEADLINES_SUCCESS,\n      headlines\n    });\n  });\n\n  it('getHeadlinesFailure should create GET_HEADLINES_FAILURE action', () => {\n    const error = \"An error\";\n    expect(actions.getHeadlinesFailure(error)).toEqual({\n      type: c.GET_HEADLINES_FAILURE,\n      error\n    });\n  });\n});\n")),(0,i.kt)("p",null,"These tests just verify that the JavaScript functions we'll create to handle our reducer actions actually complete the actions successfully."),(0,i.kt)("p",null,"Here are the functions to make our new tests pass:"),(0,i.kt)("div",{class:"filename"},"src/actions/index.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import * as c from './ActionTypes';\n\nexport const requestHeadlines = () => ({\n  type: c.REQUEST_HEADLINES\n});\n\nexport const getHeadlinesSuccess = (headlines) => ({\n  type: c.GET_HEADLINES_SUCCESS,\n  headlines\n});\n\nexport const getHeadlinesFailure = (error) => ({\n  type: c.GET_HEADLINES_FAILURE,\n  error\n});\n")),(0,i.kt)("p",null,"Note that we export each of them separately."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"At this point, we've planned out the basic state of our store and how our reducer will change it. We created constants for each of our reducer actions and then tested and created a reducer that will update the store when we make an API call. Finally, we tested and wrote action creators that will make it easier to dispatch our actions in our application."),(0,i.kt)("p",null,"However, we still haven't set up our Redux store or Thunk middleware. We also need to write an async action that will make an API call."),(0,i.kt)("p",null,"In the next lesson, we'll add Redux to our application and set up our store. Then we will use the information we learned in the previous lesson on Redux middleware to write a simple piece of custom middleware."),(0,i.kt)("p",null,"Finally, in the lesson after that, we'll incorporate Thunk and an async action."))}p.isMDXComponent=!0}}]);