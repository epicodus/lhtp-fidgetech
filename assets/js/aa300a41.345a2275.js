"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[53267],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var o=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,k=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?o.createElement(k,a(a({ref:t},p),{},{components:n})):o.createElement(k,a({ref:t},p))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8345:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(7896),i=(n(2784),n(30876));const r={title:"\ud83d\udcd3 4.3.0.9 Viewing Tickets from Firestore",id:"4309-viewing-tickets-from-firestore",slug:"4309-viewing-tickets-from-firestore",hide_table_of_contents:!0,sidebar_position:9,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/0g_viewing_tickets_from_firestore.md"},a=void 0,s={unversionedId:"fidgetech-4-react/react-with-nosql/4309-viewing-tickets-from-firestore",id:"fidgetech-4-react/react-with-nosql/4309-viewing-tickets-from-firestore",title:"\ud83d\udcd3 4.3.0.9 Viewing Tickets from Firestore",description:"We now have the ability to add tickets to Firestore in our help queue application. However, we can't see the tickets in our application yet. There are two ways we can get data from Firestore:",source:"@site/docs/fidgetech-4-react/react-with-nosql/0g-viewing-tickets-from-firestore.md",sourceDirName:"fidgetech-4-react/react-with-nosql",slug:"/fidgetech-4-react/react-with-nosql/4309-viewing-tickets-from-firestore",permalink:"/fidgetech-4-react/react-with-nosql/4309-viewing-tickets-from-firestore",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"\ud83d\udcd3 4.3.0.9 Viewing Tickets from Firestore",id:"4309-viewing-tickets-from-firestore",slug:"4309-viewing-tickets-from-firestore",hide_table_of_contents:!0,sidebar_position:9,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/fidgetech-4-react/blob/main/0g_viewing_tickets_from_firestore.md"},sidebar:"fidgetech-4-react",previous:{title:"\ud83d\udcd3 4.3.0.8 Adding Tickets to Firestore",permalink:"/fidgetech-4-react/react-with-nosql/4308-adding-tickets-to-firestore"},next:{title:"\ud83d\udcd3 4.3.0.10 Changing Selected Tickets",permalink:"/fidgetech-4-react/react-with-nosql/43010-changing-selected-tickets"}},l={},c=[],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We now have the ability to add tickets to Firestore in our help queue application. However, we can't see the tickets in our application yet. There are two ways we can get data from Firestore:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method. This is very similar to what Rails/.NET coders do with their respective frameworks. When data is needed, we make a request to Firestore.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We can set up a listener that actively listens for changes in Firestore. Whenever Firestore is updated, our application will get a snapshot of the data and update accordingly."))),(0,i.kt)("p",null,"If we were to do the former, we might add a ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method to the ",(0,i.kt)("inlineCode",{parentName:"p"},"componentDidMount()")," lifecycle hook in ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl.js"),". Our application wouldn't change too much because we already have props to pass values down to ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketList.js")," and then eventually to ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketDetail.js"),". However, if we were to do this, our application would only update when the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl")," component is mounted - not when data is actually updated. That's not a big deal for a small application intended to be used only in one place (the help queue at Epicodus) but in a bigger application, we'd be missing out on a major benefit of Firestore - real-time updating of data."),(0,i.kt)("p",null,"Fortunately, React Redux Firebase provides both a higher order component and a hook for the second option. We could either use an HOC in ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl.js")," or we could use a hook in a function component. Our ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl")," component actually doesn't need to know about all the tickets - the only reason we've used it for that purpose so far is to keep our state in one place."),(0,i.kt)("p",null,"Now that we can use a hook, though, we can just pass in tickets from Firestore where they are needed - the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketList")," component. There's no need to make ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketList.js")," a class component, either. In fact, we'll be using two hooks - one from React Redux Firebase and one from React Redux."),(0,i.kt)("p",null,"Let's take a look at the updated ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketList.js")," file. Because there will be a number of changes, we'll annotate the code with comments again."),(0,i.kt)("div",{class:"filename"},"src/components/TicketList.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\n// We need to import hooks functionality from both react-redux and react-redux-firebase.\nimport { useSelector } from 'react-redux'\nimport { useFirestoreConnect, isLoaded, isEmpty } from 'react-redux-firebase'\n\n\nfunction TicketList(props){\n  // The useFirestoreConnect() hook comes from react-redux-firebase.\n  useFirestoreConnect([\n    { collection: 'tickets' }\n  ]);\n\n  // The useSelector() hook comes from react-redux.\n  const tickets = useSelector(state => state.firestore.ordered.tickets);\n  \n  // react-redux-firebase also offers a useful isLoaded() function.\n  if (isLoaded(tickets)) {\n    return (\n      <React.Fragment>\n        <hr/>\n        {tickets.map((ticket) => {\n          return <Ticket\n            whenTicketClicked = { props.onTicketSelection }\n            names={ticket.names}\n            location={ticket.location}\n            issue={ticket.issue}\n            formattedWaitTime={ticket.formattedWaitTime}\n            id={ticket.id}\n            key={ticket.id}/>\n        })}\n      </React.Fragment>\n    );\n  // If the tickets aren't loaded yet, our fragment will return a \"Loading...\" message.\n  } else {\n    return (\n      <React.Fragment>\n        <h3>Loading...</h3>\n      </React.Fragment>\n    )\n  }\n}\n\nTicketList.propTypes = {\n  // We no longer need ticketList props.\n  // ticketList: PropTypes.object,\n  onTicketSelection: PropTypes.func\n};\n\nexport default TicketList;\n")),(0,i.kt)("p",null,"Let's look at this in greater detail. First, we need to import the following from ",(0,i.kt)("inlineCode",{parentName:"p"},"react-redux")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"react-redux-firebase"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { useSelector } from 'react-redux'\nimport { useFirestoreConnect, isLoaded, isEmpty } from 'react-redux-firebase'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useSelector()")," hook from ",(0,i.kt)("inlineCode",{parentName:"p"},"react-redux")," allows us to extract data from a Redux store.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useFirestoreConnect()")," hook from ",(0,i.kt)("inlineCode",{parentName:"p"},"react-redux-firebase")," allows us to listen for changes to Firestore without using an HOC in a class component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"isLoaded()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"isEmpty()")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"react-redux-firebase")," allow us to check if a collection has been retrieved from Firestore."))),(0,i.kt)("p",null,"We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"useFirestoreConnect()")," hook like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"useFirestoreConnect([\n  { collection: 'tickets' }\n]);\n")),(0,i.kt)("p",null,"We specify the collection or documents we want to listen to in Firestore. In this case, we want the entire collection of tickets. However, we could also use this hook to find a ticket with a specific id by doing the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"useFirestoreConnect([\n  { \n    collection: 'tickets',\n    doc: ticketId \n  }\n]);\n")),(0,i.kt)("p",null,"This specifies that ",(0,i.kt)("inlineCode",{parentName:"p"},"useFirestoreConnect()")," should listen for changes to a document with an id of ",(0,i.kt)("inlineCode",{parentName:"p"},"ticketId")," from the tickets collection."),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"useFirestoreConnect()")," is listening for changes to Firestore, we also need to take advantage of a React Redux hook called ",(0,i.kt)("inlineCode",{parentName:"p"},"useSelector()")," which makes state available from our store. All Firestore data is still passing through our store through our ",(0,i.kt)("inlineCode",{parentName:"p"},"firestoreReducer"),". We need to make it available with the ",(0,i.kt)("inlineCode",{parentName:"p"},"useSelector()")," hook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const tickets = useSelector(state => state.firestore.tickets);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"firestoreReducer")," passes data into a ",(0,i.kt)("inlineCode",{parentName:"p"},"firestore")," data slice. That's where we need to grab from: ",(0,i.kt)("inlineCode",{parentName:"p"},"state.firestore.tickets"),". We save our collection in a constant called ",(0,i.kt)("inlineCode",{parentName:"p"},"tickets"),"."),(0,i.kt)("p",null,"Next, we verify that the tickets collection has loaded ",(0,i.kt)("strong",{parentName:"p"},"before")," we try to render our component. We do this with a conditional that checks if ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoaded(tickets)"),". This is an extremely useful piece of functionality. If we try to load our tickets before we've retrieved the data, our application will throw an error. React Redux Firebase also provides ",(0,i.kt)("inlineCode",{parentName:"p"},"isEmpty()")," as an option as well. We aren't using it in this component but we've added it to the import statement just to show that it's available to use where needed."),(0,i.kt)("p",null,"Note we've also updated our ",(0,i.kt)("inlineCode",{parentName:"p"},"map()")," function - we no longer need to iterate over tickets by checking their keys. We've also removed the ticket's ",(0,i.kt)("inlineCode",{parentName:"p"},"formattedWaitTime")," for now."),(0,i.kt)("p",null,"Finally, our ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," statement contains a simple ",(0,i.kt)("inlineCode",{parentName:"p"},"Loading...")," message. ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketList.js")," will render this message until the tickets are loaded - at that point, the component will be re-rendered and the user will see the tickets from Firestore."),(0,i.kt)("p",null,"At this point, we no longer need the ",(0,i.kt)("inlineCode",{parentName:"p"},"ticketList")," prop. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl")," component no longer needs to pass down ",(0,i.kt)("inlineCode",{parentName:"p"},"this.props.mainTicketList")," either, so you can remove that now. You also will want to comment out or remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"componentDidMount()")," statement in TicketControl.js, as it will throw an error after a minute, when it attempts to update the wait time. There are other refactors we can make to ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketControl.js"),", but we won't worry about them at the moment since they aren't actively breaking our application."),(0,i.kt)("p",null,"Our application will work correctly and display tickets now. However, we still have quite a bit of functionality to add to get our application fully working. For instance, if we click on a ticket, nothing happens. In the next lesson, we'll fix that."))}u.isMDXComponent=!0}}]);